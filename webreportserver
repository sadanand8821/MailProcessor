package com.example;

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;

import java.io.*;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class WebReportServer {

    private static Map<String, List<String>> repoData;
    private static Map<String, DevInfo> devMap;

    public static void main(String[] args) throws Exception {
        repoData = ExcelReader.readRepoData("RepoURLs.xlsx");
        devMap = ExcelReader.readDevMap("DevMap.xlsx");

        HttpServer server = HttpServer.create(new InetSocketAddress(8080), 0);
        server.createContext("/", new FormHandler());
        server.createContext("/generate", new GenerateHandler());

        server.setExecutor(null);
        server.start();
        System.out.println("Server running at http://localhost:8080/");
    }

    static class FormHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"GET".equalsIgnoreCase(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, -1);
                return;
            }

            // Build form with repo, branch, and developer dropdowns
            StringBuilder form = new StringBuilder("<html><head><title>Commit Report</title></head><body>");
            form.append("<h1>Select Parameters for Commit Report</h1>");
            form.append("<form method='GET' action='/generate'>");
            form.append("After Date (YYYY-MM-DD): <input name='afterDate' value='2023-01-01'><br><br>");
            form.append("Before Date (YYYY-MM-DD): <input name='beforeDate' value='2023-12-31'><br><br>");

            // Repo dropdown
            form.append("Repository: <select name='repoUrl'>");
            form.append("<option value='ALL'>All Repositories</option>");
            for (String repoUrl : repoData.keySet()) {
                form.append("<option value='").append(repoUrl).append("'>").append(repoUrl).append("</option>");
            }
            form.append("</select><br><br>");

            // Branch dropdown
            Set<String> allBranches = new HashSet<>();
            for (List<String> brs : repoData.values()) {
                allBranches.addAll(brs);
            }
            form.append("Branch: <select name='branch'>");
            form.append("<option value='ALL'>All Branches</option>");
            for (String b : allBranches) {
                form.append("<option value='").append(b).append("'>").append(b).append("</option>");
            }
            form.append("</select><br><br>");

            // Developer dropdown
            form.append("Developer: <select name='developer'>");
            form.append("<option value='ALL'>All Developers</option>");
            for (DevInfo dev : devMap.values()) {
                form.append("<option value='").append(dev.getUid()).append("'>")
                        .append(dev.getName()).append(" (").append(dev.getUid()).append(")</option>");
            }
            form.append("</select><br><br>");

            form.append("<input type='submit' value='Generate'>");
            form.append("</form></body></html>");

            byte[] bytes = form.toString().getBytes(StandardCharsets.UTF_8);
            exchange.sendResponseHeaders(200, bytes.length);
            try (OutputStream os = exchange.getResponseBody()) {
                os.write(bytes);
            }
        }
    }

    static class GenerateHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"GET".equalsIgnoreCase(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, -1);
                return;
            }

            String query = exchange.getRequestURI().getQuery();
            Map<String, String> params = parseQuery(query);

            String afterDate = params.getOrDefault("afterDate", "2023-01-01");
            String beforeDate = params.getOrDefault("beforeDate", "2023-12-31");
            String repoUrl = params.getOrDefault("repoUrl", "ALL");
            String branch = params.getOrDefault("branch", "ALL");
            String developerUid = params.getOrDefault("developer", "ALL");

            exchange.sendResponseHeaders(200, 0);
            OutputStream os = exchange.getResponseBody();
            PrintWriter pw = new PrintWriter(new OutputStreamWriter(os, StandardCharsets.UTF_8), true);

            // Processing message
            pw.println("<html><head><title>Processing</title>");
            pw.println("<style>");
            pw.println("body { font-family: Arial, sans-serif; background: #f9f9f9; }");
            pw.println("h1, h2 { color: #333; }");
            pw.println("table { border-collapse: collapse; width: 80%; margin: 20px auto; }");
            pw.println("th, td { border: 1px solid #ccc; padding: 8px; text-align: left; vertical-align: top; }");
            pw.println("th { background: #f2f2f2; }");
            pw.println("td { max-width: 200px; word-wrap: break-word; overflow-wrap: break-word; }");
            pw.println(".center { text-align: center; margin-top:50px; }");
            pw.println("</style></head><body>");
            pw.println("<div class='center'><h2>Processing your request, please wait...</h2></div>");
            pw.flush();

            Map<String, Integer> globalAuthorCounts = new HashMap<>();

            try {
                // Process repositories and branches based on user input
                if (repoUrl.equals("ALL")) {
                    for (Map.Entry<String, List<String>> entry : repoData.entrySet()) {
                        String currentRepo = entry.getKey();
                        List<String> branches = entry.getValue();
                        if (branch.equals("ALL")) {
                            processRepoBranches(currentRepo, branches, afterDate, beforeDate, globalAuthorCounts);
                        } else if (branches.contains(branch)) {
                            processSingleRepoBranch(currentRepo, branch, afterDate, beforeDate, globalAuthorCounts);
                        }
                    }
                } else {
                    List<String> branches = repoData.get(repoUrl);
                    if (branches != null) {
                        if (branch.equals("ALL")) {
                            processRepoBranches(repoUrl, branches, afterDate, beforeDate, globalAuthorCounts);
                        } else if (branches.contains(branch)) {
                            processSingleRepoBranch(repoUrl, branch, afterDate, beforeDate, globalAuthorCounts);
                        }
                    }
                }

                // Normalize authors and generate report
                Map<String, Integer> finalUidCounts = normalizeAuthors(globalAuthorCounts, devMap);
                pw.println("<h1 style='text-align:center;'>Commit Report</h1>");
                pw.println("<p style='text-align:center;'><b>Repository:</b> " + repoUrl + "<br>");
                pw.println("<b>Branch:</b> " + branch + "<br>");
                pw.println("<b>Date Range:</b> " + afterDate + " to " + beforeDate + "</p>");
                pw.println(generateHtmlReport(finalUidCounts, devMap, developerUid));
                pw.println("</body></html>");
            } catch (Exception e) {
                pw.println("<h2>Error occurred: " + e.getMessage() + "</h2></body></html>");
            } finally {
                pw.close();
            }
        }
    }

    // Utility methods

    private static String generateHtmlReport(Map<String, Integer> finalUidCounts, Map<String, DevInfo> devMap, String developerUid, Map<String, Map<String, Map<String, Integer>>> repoBranchCounts) {
    StringBuilder html = new StringBuilder();
    html.append("<table>");
    html.append("<tr><th>Repository</th><th>Branch</th><th>UID</th><th>Name</th><th>Commits</th></tr>");

    for (Map.Entry<String, Map<String, Map<String, Integer>>> repoEntry : repoBranchCounts.entrySet()) {
        String repoName = repoEntry.getKey();
        Map<String, Map<String, Integer>> branchData = repoEntry.getValue();

        for (Map.Entry<String, Map<String, Integer>> branchEntry : branchData.entrySet()) {
            String branchName = branchEntry.getKey();
            Map<String, Integer> developerCounts = branchEntry.getValue();

            boolean isFirstBranchRow = true;

            for (Map.Entry<String, Integer> devEntry : developerCounts.entrySet()) {
                String uid = devEntry.getKey();
                int commitCount = devEntry.getValue();

                // Filter developers if a specific UID is selected
                if (!developerUid.equals("ALL") && !uid.equals(developerUid)) {
                    continue;
                }

                DevInfo devInfo = devMap.get(uid);
                String name = devInfo != null ? devInfo.getName() : "Unknown Developer";

                html.append("<tr>");
                if (isFirstBranchRow) {
                    html.append("<td rowspan='").append(developerCounts.size()).append("'>").append(repoName).append("</td>");
                    html.append("<td rowspan='").append(developerCounts.size()).append("'>").append(branchName).append("</td>");
                    isFirstBranchRow = false;
                }

                html.append("<td>").append(uid).append("</td>");
                html.append("<td>").append(name).append("</td>");
                html.append("<td>").append(commitCount).append("</td>");
                html.append("</tr>");
            }
        }
    }

    html.append("</table>");
    return html.toString();
}

    private static void processRepoBranches(String repoUrl, List<String> branches, String afterDate, String beforeDate, Map<String, Integer> globalAuthorCounts) throws IOException, InterruptedException {
        for (String branch : branches) {
            processSingleRepoBranch(repoUrl, branch, afterDate, beforeDate, globalAuthorCounts);
        }
    }

    private static void processSingleRepoBranch(String repoUrl, String branch, String afterDate, String beforeDate, Map<String, Integer> globalAuthorCounts) throws IOException, InterruptedException {
        String repoName = extractRepoName(repoUrl);
        File repoFolder = new File("Code Commit Counts", repoName);

        cloneRepository(repoFolder.getParentFile(), repoUrl, repoName);

        List<String> shortlogOutput = runShortlog(repoFolder, branch, afterDate, beforeDate);
        parseShortlogOutput(shortlogOutput, globalAuthorCounts);

        deleteDirectory(repoFolder);
    }

    private static void cloneRepository(File baseDir, String repoUrl, String repoName) throws IOException, InterruptedException {
        List<String> cloneCmd = Arrays.asList("git", "clone", repoUrl, repoName);
        GitCommandExecutor.runGitCommand(baseDir, cloneCmd);
    }

    private static List<String> runShortlog(File repoFolder, String branch, String afterDate, String beforeDate) throws IOException, InterruptedException {
        List<String> shortlogCmd = Arrays.asList(
                "git", "shortlog", "-s", "-n", "-e", branch,
                "--after=" + afterDate,
                "--before=" + beforeDate
        );
        return GitCommandExecutor.runGitCommand(repoFolder, shortlogCmd);
    }

    private static void parseShortlogOutput(List<String> lines, Map<String, Integer> counts) {
        for (String line : lines) {
            String trimmed = line.trim();
            if (trimmed.isEmpty()) continue;
            int spaceIndex = indexOfFirstNonDigit(trimmed);
            if (spaceIndex == -1) continue;
            String countStr = trimmed.substring(0, spaceIndex).trim();
            String author = trimmed.substring(spaceIndex).trim();
            try {
                int commitCount = Integer.parseInt(countStr);
                counts.put(author, counts.getOrDefault(author, 0) + commitCount);
            } catch (NumberFormatException e) {
                System.err.println("Failed to parse commit count from line: " + line);
            }
        }
    }

    private static int indexOfFirstNonDigit(String str) {
        for (int i = 0; i < str.length(); i++) {
            if (!Character.isDigit(str.charAt(i))) {
                return i;
            }
        }
        return -1;
    }

    private static Map<String, Integer> normalizeAuthors(Map<String, Integer> authorCounts, Map<String, DevInfo> devMap) {
        if (devMap == null) return authorCounts;

        Map<String, Integer> normalizedCounts = new HashMap<>();
        for (Map.Entry<String, DevInfo> entry : devMap.entrySet()) {
            String uid = entry.getKey();
            DevInfo info = entry.getValue();

            int total = 0;
            Set<String> keys = new HashSet<>(info.getAliases());
            keys.add(uid);
            keys.add(info.getName());

            for (String key : keys) {
                total += authorCounts.getOrDefault(key, 0);
            }

            normalizedCounts.put(uid, total);
        }
        return normalizedCounts;
    }

    private static String extractRepoName(String repoUrl) {
        String name = repoUrl.substring(repoUrl.lastIndexOf('/') + 1);
        if (name.endsWith(".git")) {
            name = name.substring(0, name.length() - 4);
        }
        return name;
    }

    private static void deleteDirectory(File dir) {
        if (!dir.exists()) return;
        if (dir.isDirectory()) {
            File[] files = dir.listFiles();
            if (files != null) {
                for (File f : files) {
                    deleteDirectory(f);
                }
            }
        }
        dir.delete();
    }

    private static Map<String, String> parseQuery(String query) {
        Map<String, String> params = new HashMap<>();
        if (query != null && !query.isEmpty()) {
            for (String pair : query.split("&")) {
                String[] kv = pair.split("=");
                if (kv.length == 2) {
                    params.put(kv[0], kv[1]);
                }
            }
        }
        return params;
    }
}
