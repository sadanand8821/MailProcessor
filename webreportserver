package com.example;

import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import java.io.*;
import java.net.InetSocketAddress;
import java.nio.charset.StandardCharsets;
import java.util.*;

public class WebReportServer {

    // Static references for repoData and devMap loaded once at startup
    private static Map<String, List<String>> repoData;
    private static Map<String, DevInfo> devMap;

    public static void main(String[] args) throws Exception {
        // Load repoData from RepoURLs.xlsx
        repoData = ExcelReader.readRepoData("RepoURLs.xlsx");
        // Load devMap from DevMap.xlsx
        devMap = ExcelReader.readDevMap("DevMap.xlsx");

        HttpServer server = HttpServer.create(new InetSocketAddress(8080), 0);

        // Form page
        server.createContext("/", new FormHandler());

        // Generate report
        server.createContext("/generate", new GenerateHandler());

        server.setExecutor(null);
        server.start();
        System.out.println("Server running at http://localhost:8080/");
    }

    static class FormHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"GET".equalsIgnoreCase(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, -1);
                return;
            }

            // Build the form
            StringBuilder form = new StringBuilder("<html><body>");
            form.append("<h1>Generate Commit Report</h1>");
            form.append("<form method='GET' action='/generate'>");
            form.append("After Date (YYYY-MM-DD): <input name='afterDate' value='2023-01-01'><br><br>");
            form.append("Before Date (YYYY-MM-DD): <input name='beforeDate' value='2023-12-31'><br><br>");

            // Repository Dropdown
            form.append("Repository: <select name='repoUrl'>");
            form.append("<option value='ALL'>All Repositories</option>");
            for (String repoUrl : repoData.keySet()) {
                form.append("<option value='").append(repoUrl).append("'>").append(repoUrl).append("</option>");
            }
            form.append("</select><br><br>");

            // Branch Dropdown
            // Collect all distinct branches from all repos
            Set<String> allBranches = new HashSet<>();
            for (List<String> brs : repoData.values()) {
                allBranches.addAll(brs);
            }

            form.append("Branch: <select name='branch'>");
            form.append("<option value='ALL'>All Branches</option>");
            for (String b : allBranches) {
                form.append("<option value='").append(b).append("'>").append(b).append("</option>");
            }
            form.append("</select><br><br>");

            form.append("<input type='submit' value='Generate'>");
            form.append("</form></body></html>");

            byte[] bytes = form.toString().getBytes(StandardCharsets.UTF_8);
            exchange.sendResponseHeaders(200, bytes.length);
            try (OutputStream os = exchange.getResponseBody()) {
                os.write(bytes);
            }
        }
    }

    static class GenerateHandler implements HttpHandler {
        @Override
        public void handle(HttpExchange exchange) throws IOException {
            if (!"GET".equalsIgnoreCase(exchange.getRequestMethod())) {
                exchange.sendResponseHeaders(405, -1);
                return;
            }

            String query = exchange.getRequestURI().getQuery();
            Map<String, String> params = parseQuery(query);

            String afterDate = params.getOrDefault("afterDate", "2023-01-01");
            String beforeDate = params.getOrDefault("beforeDate", "2023-12-31");
            String repoUrl = params.getOrDefault("repoUrl", "ALL");
            String branch = params.getOrDefault("branch", "ALL");

            exchange.sendResponseHeaders(200, 0);
            OutputStream os = exchange.getResponseBody();
            PrintWriter pw = new PrintWriter(new OutputStreamWriter(os, StandardCharsets.UTF_8), true);

            // Show processing message first
            pw.println("<html><head><title>Processing</title></head><body>");
            pw.println("<h2>Processing your request, please wait...</h2>");
            pw.flush(); // User sees this message before we start heavy work

            // Prepare working directory
            String baseDirName = "Code Commit Counts";
            File baseDir = new File(baseDirName);
            if (!baseDir.exists()) {
                baseDir.mkdir();
            }

            Map<String, Integer> globalAuthorCounts = new HashMap<>();

            try {
                // Determine which repos and branches to process
                if (repoUrl.equals("ALL")) {
                    // All repos
                    for (Map.Entry<String, List<String>> entry : repoData.entrySet()) {
                        String currentRepo = entry.getKey();
                        List<String> branches = entry.getValue();
                        if (branch.equals("ALL")) {
                            // All branches for this repo
                            processRepoBranches(currentRepo, branches, afterDate, beforeDate, baseDir, globalAuthorCounts);
                        } else {
                            // Specific branch, if it exists
                            if (branches.contains(branch)) {
                                processSingleRepoBranch(currentRepo, branch, afterDate, beforeDate, baseDir, globalAuthorCounts);
                            } else {
                                System.err.println("Branch " + branch + " not found in " + currentRepo + ". Skipping.");
                            }
                        }
                    }
                } else {
                    // Single repo
                    List<String> branches = repoData.get(repoUrl);
                    if (branches == null) {
                        System.err.println("Repo " + repoUrl + " not found in repoData.");
                    } else {
                        if (branch.equals("ALL")) {
                            // All branches for chosen repo
                            processRepoBranches(repoUrl, branches, afterDate, beforeDate, baseDir, globalAuthorCounts);
                        } else {
                            // Specific branch
                            if (branches.contains(branch)) {
                                processSingleRepoBranch(repoUrl, branch, afterDate, beforeDate, baseDir, globalAuthorCounts);
                            } else {
                                System.err.println("Branch " + branch + " not found in " + repoUrl + ". Skipping.");
                            }
                        }
                    }
                }

                // Normalize authors using devMap
                Map<String, Integer> finalUidCounts = normalizeAuthors(globalAuthorCounts, devMap);

                // After done, show the final results
                pw.println("<h2>Done! Here are the results:</h2>");
                pw.println("<p><b>Repository:</b> " + repoUrl + "</p>");
                pw.println("<p><b>Branch:</b> " + branch + "</p>");
                pw.println("<p><b>Date Range:</b> " + afterDate + " to " + beforeDate + "</p>");
                pw.println(generateHtmlReport(finalUidCounts, devMap));
                pw.println("</body></html>");

            } catch (Exception e) {
                String error = "<h2>Error occurred: " + e.getMessage() + "</h2></body></html>";
                pw.println(error);
            } finally {
                pw.close();
            }
        }

        private void processRepoBranches(String repoUrl, List<String> branches, String afterDate, String beforeDate, File baseDir, Map<String, Integer> globalAuthorCounts) throws IOException, InterruptedException {
            for (String br : branches) {
                processSingleRepoBranch(repoUrl, br, afterDate, beforeDate, baseDir, globalAuthorCounts);
            }
        }

        private void processSingleRepoBranch(String repoUrl, String branch, String afterDate, String beforeDate, File baseDir, Map<String, Integer> globalAuthorCounts) throws IOException, InterruptedException {
            String repoName = extractRepoName(repoUrl);
            // Clone the repo
            cloneRepository(baseDir, repoUrl, repoName);

            File repoFolder = new File(baseDir, repoName);
            if (!repoFolder.exists()) {
                System.err.println("Repo folder not created for " + repoUrl);
                return;
            }

            List<String> shortlogOutput = runShortlog(repoFolder, branch, afterDate, beforeDate);
            parseShortlogOutput(shortlogOutput, globalAuthorCounts);

            deleteDirectory(repoFolder);
        }

        private static Map<String, String> parseQuery(String query) {
            Map<String, String> params = new HashMap<>();
            if (query != null && !query.isEmpty()) {
                for (String pair : query.split("&")) {
                    String[] kv = pair.split("=");
                    if (kv.length == 2) {
                        params.put(kv[0], kv[1]);
                    }
                }
            }
            return params;
        }
    }

    // Utilities and helper methods

    private static String extractRepoName(String repoUrl) {
        String name = repoUrl.substring(repoUrl.lastIndexOf('/') + 1);
        if (name.endsWith(".git")) {
            name = name.substring(0, name.length() - 4);
        }
        return name;
    }

    private static void cloneRepository(File baseDir, String repoUrl, String repoName) throws IOException, InterruptedException {
        List<String> cloneCmd = Arrays.asList("git", "clone", repoUrl, repoName);
        GitCommandExecutor.runGitCommand(baseDir, cloneCmd);
    }

    private static List<String> runShortlog(File repoFolder, String branch, String afterDate, String beforeDate) throws IOException, InterruptedException {
        List<String> shortlogCmd = Arrays.asList(
                "git", "shortlog", "-s", "-n", "-e",
                branch,
                "--after=" + afterDate,
                "--before=" + beforeDate
        );
        return GitCommandExecutor.runGitCommand(repoFolder, shortlogCmd);
    }

    private static void parseShortlogOutput(List<String> lines, Map<String, Integer> counts) {
        for (String line : lines) {
            String trimmed = line.trim();
            if (trimmed.isEmpty()) continue;
            int spaceIndex = indexOfFirstNonDigit(trimmed);
            if (spaceIndex == -1) continue;
            String countStr = trimmed.substring(0, spaceIndex).trim();
            String author = trimmed.substring(spaceIndex).trim();
            try {
                int commitCount = Integer.parseInt(countStr);
                counts.put(author, counts.getOrDefault(author, 0) + commitCount);
            } catch (NumberFormatException e) {
                System.err.println("Failed to parse commit count from line: " + line);
            }
        }
    }

    private static int indexOfFirstNonDigit(String str) {
        for (int i = 0; i < str.length(); i++) {
            if (!Character.isDigit(str.charAt(i))) {
                return i;
            }
        }
        return -1;
    }

    private static Map<String, Integer> normalizeAuthors(Map<String, Integer> authorCounts, Map<String, DevInfo> devMap) {
        if (devMap == null) {
            // No devMap means just return authorCounts as is (no names, just the raw authors)
            // or you could create fake UIDs.
            // Let's return as-is but keyed by author string:
            // For simplicity, generate a synthetic UID (the author name is UID).
            Map<String, Integer> result = new HashMap<>();
            for (Map.Entry<String, Integer> e : authorCounts.entrySet()) {
                // Use author as UID here if no devMap
                result.put(e.getKey(), e.getValue());
            }
            return result;
        }

        Map<String, Integer> finalUidCounts = new HashMap<>();
        for (Map.Entry<String, DevInfo> entry : devMap.entrySet()) {
            String uid = entry.getKey();
            DevInfo info = entry.getValue();
            int total = 0;
            for (String alias : info.getAliases()) {
                total += authorCounts.getOrDefault(alias, 0);
            }
            finalUidCounts.put(uid, total);
        }
        return finalUidCounts;
    }

    private static String generateHtmlReport(Map<String, Integer> finalUidCounts, Map<String, DevInfo> devMap) {
        StringBuilder html = new StringBuilder();
        html.append("<table border='1' style='border-collapse:collapse;'>");
        html.append("<tr><th>UID</th><th>Name</th><th>Commits</th></tr>");

        for (Map.Entry<String, Integer> entry : finalUidCounts.entrySet()) {
            String uid = entry.getKey();
            int commits = entry.getValue();
            String name = "";
            if (devMap != null && devMap.containsKey(uid)) {
                name = devMap.get(uid).getName();
            } else if (devMap == null) {
                // If no devMap, uid might actually be the raw author string
                name = uid; 
            }

            html.append("<tr><td>").append(uid).append("</td>")
                    .append("<td>").append(name).append("</td>")
                    .append("<td>").append(commits).append("</td></tr>");
        }

        html.append("</table>");
        return html.toString();
    }

    private static void deleteDirectory(File dir) {
        if (!dir.exists()) return;
        if (dir.isDirectory()) {
            File[] files = dir.listFiles();
            if (files != null) {
                for (File f : files) {
                    deleteDirectory(f);
                }
            }
        }
        dir.delete();
    }

    // DevInfo class to hold UID, Name, and Aliases
    // This matches the structure of DevMap.xlsx:
    // UID | Name | Alias1 | Alias2 ...
    public static class DevInfo {
        private String uid;
        private String name;
        private Set<String> aliases;

        public DevInfo(String uid, String name, Set<String> aliases) {
            this.uid = uid;
            this.name = name;
            this.aliases = aliases;
        }

        public String getUid() {
            return uid;
        }

        public String getName() {
            return name;
        }

        public Set<String> getAliases() {
            return aliases;
        }
    }
}
